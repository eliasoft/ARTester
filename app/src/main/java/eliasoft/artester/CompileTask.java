/*
* Copyright (C) 2022 ELIASoft <eliasoft.developer@gmail.com>.
*
* This file is part of ARTester.
*
* ARTester is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

package eliasoft.artester;
import android.content.Intent;
import android.util.Pair;
import java.io.*;
import java.util.*;
import java.util.concurrent.atomic.*;
import javax.tools.*;
import com.sun.source.util.*;
import eliasoft.common.*;

@SuppressWarnings("deprecation")
public class CompileTask extends android.os.AsyncTask<Void, Void, ArrayList<String>>{
	private java.lang.ref.WeakReference<MainActivity> activityRef;
	private String mainTestClass;// when compiling a project this field takes a value referring to the "MainTest.java" file. for example: mainTestClass="MainTest" or mainTestClass="com.yourpackage.MainTest".
	private String dexPaths="";// list of .dex files to execute on the TestActivity when compilation finalize successfully. E.q.: dexPaths="MainTest.dex/Other.dex/Blabla.dex";
	private boolean allWentWell;// true if javac and r8 is executed properly.
	CompileTask(MainActivity aty){activityRef=new java.lang.ref.WeakReference<>(aty);}

	@Override protected ArrayList<String> doInBackground(Void... v){
		ArrayList<String> msgs=new ArrayList<>();// diagnostic messages to be returned from doInBackground() method..
		File projectDir=App.currentProject.getParentFile();
		File buildDir=new File(projectDir, "build");buildDir.mkdir();
		File boosterFile=new File(buildDir, "compiler_speed_booster.properties");// that file will be generated if it did not exists at the time the javac tool runs without errors, and each time you modify, add or delete java files inside the specified directories in the project's config.txt file. please read the following line.
		String boosterFileComment=" This file is intended to fulfill two requirements.\n"
			+"#    The first of these is to prevent the Javac tool from compiling those *.java files, which have not been modified since the last time this project was compiled.\n"
			+"#    And the second requirement is to prevent the D8 tool from running for those *.jar files and *.class files, which have not been modified since the last time this project was compiled.\n"
			+"# NOTE: When a *.java file is deleted, its reference will be removed from this file on the next successful javac compilation. In case this file contains information about deleted *.jar files, you must modify this file, or delete it so that it will be created again (containing only the references for necessary *.jar files).\n"
			+"#\n# This file consists of a map of path=file.lastModified() entries separated by a newline. where each path can be of two forms:\n"
			+"#    For *.jar files it will be their absolute file path.\n"
			+"#    For *.java files it will be their short file path, which can be understood by viewing some examples.\n"
			+"#        Example 1. if we have a file whose path is \"/storage/emulated/0/AndroidProjects/example/ARTester/java/com/example/Something.java\", its short path would be \"com/example/Someclass.java\"\n"
			+"#        Example 2. if we have a file whose path is \"/storage/emulated/0/AndroidProjects/example/ARTester/java/Something.java\", its short path would be \"Someclass.java\"\n"
			+"#        Example 3. if we have a file whose path is \"/storage/emulated/0/someArbitrary/blablabla/ARTester/java/com/blablabla/Something.java\", its short path would be \"com/blablabla/Someclass.java\"\n";
		final ArrayList<JavaFileObject> javaFiles=new ArrayList<>();// this list will contain only the java files that has been modified. for understand, read the boosterFileComment.
		ArrayList<String> classFiles=new ArrayList<>();// this list will contain the file paths that the ".class" files that will be generated by compiling the java files that exist at the time of running javac are supposed to have. therefore, if there is a ".class" file in the "build" directory whose file path is not present in this list, it will be considered a residual file and will be permanently deleted.
		final ArrayList<File> jarFiles=new ArrayList<>();// read the boosterFileComment.
		ArrayList<String> nonModifiedFiles=new ArrayList<>();// read the boosterFileComment.
		HashMap<String, String> shortPaths=new HashMap</* String fullPath, String shortPath */>();
		ArrayList<File> projectClasspaths=new ArrayList<>();projectClasspaths.add(buildDir);
		try{
			AtomicBoolean hasPendingCompilation=new AtomicBoolean();
			AtomicBoolean willWriteBoosterFile=new AtomicBoolean();
			Properties boosterMap=new Properties();if(boosterFile.exists())boosterMap.load(new FileInputStream(boosterFile));
			App.l("reading "+App.currentProject);
			BufferedReader configReader=new BufferedReader(new FileReader(App.currentProject));
			String l; while((l=configReader.readLine())!=null){
				if(l.length()==0||l.charAt(0)=='#'||l.charAt(0)=='"'||l.contains(" "))continue;
				AtomicReference<File> sourceDir=new AtomicReference<>();
				if(l.charAt(0)==File.separatorChar)sourceDir.set(new File(l));
				else{sourceDir.set(new File(projectDir, l));try{sourceDir.set(new File(sourceDir.get().getCanonicalPath()));}catch(IOException ioe){sourceDir.set(null);App.l("Error: sourceDir.getCanonicalPath() "+l);}}
				if(sourceDir.get()==null ||!sourceDir.get().canRead())continue;
				if(sourceDir.get().isFile())sourceDir.set(sourceDir.get().getParentFile());
				DirectoryTraverser.forEachFile(sourceDir.get(), (file, loop)->{
					String shortPath=file.getPath().substring(sourceDir.get().getPath().length()+1);
					if(file.getName().endsWith(".jar")){jarFiles.add(file);
						if(file.lastModified()==Long.parseLong(boosterMap.getProperty(file.getPath(), "0")))nonModifiedFiles.add(file.getPath());
						else boosterMap.setProperty(file.getPath(), String.valueOf(file.lastModified()));
					}else if(file.getName().endsWith(".java")){
						String expectedClass=buildDir.getPath()+File.separator+shortPath.replace(".java",".class");
						shortPaths.put(file.getPath(), shortPath); classFiles.add(expectedClass);
						if(mainTestClass==null&&file.getName().equals("MainTest.java"))mainTestClass=shortPath.substring(0,shortPath.length()-5).replace(File.separator,".");
						if(new File(expectedClass).exists()&&file.lastModified()==Long.parseLong(boosterMap.getProperty(shortPath, "0"))){nonModifiedFiles.add(expectedClass);return;}
						hasPendingCompilation.set(javaFiles.add(new SimpleJavaFileObject(file.toURI(), JavaFileObject.Kind.SOURCE){
							public CharSequence getCharContent(boolean b) throws IOException{
								byte[] bytes=new byte[(int)file.length()]; DataInputStream dis=new DataInputStream(new FileInputStream(file));dis.readFully(bytes);dis.close(); String s=new String(bytes);
								BufferedReader packageStatementFinder=new BufferedReader(new StringReader(s));
								String pkg="package "; String l2; while((l2=packageStatementFinder.readLine())!=null){
									l2=l2.trim();if(l2.startsWith(pkg)&&l2.contains(";")){pkg=l2.replace(".",File.separator).substring(0,l2.indexOf(";"));break;}
								} packageStatementFinder.close();
								if(pkg.substring(8).equals(shortPath.contains(File.separator)?shortPath.substring(0,shortPath.lastIndexOf(File.separator)):""))return s;
								else throw new IOException("\n_______ The package statement does not match with the directory structure.");
							}
						})); boosterMap.setProperty(shortPath, String.valueOf(file.lastModified()));
					}else if(file.getName().endsWith(".class")){
						File f=new File(buildDir.getPath(), shortPath);
						classFiles.add(f.getPath()); if(f.exists())return;
						FileOutputStream fos=new FileOutputStream(f);
						FileInputStream fis=new FileInputStream(file);byte[] buf=new byte[4096];
						int len=0;while((len=fis.read(buf))>=0){fos.write(buf, 0, len);}
						fos.close();fis.close();
					}
				});
			}
			configReader.close();
			App.l("generated shortPaths "+shortPaths.toString());
			if(mainTestClass==null){App.notice(activityRef.get(), true, "The file MainTest.java does not exists");return null;}
			DiagnosticCollector<JavaFileObject> dc=new DiagnosticCollector<>();
			com.sun.tools.javac.api.JavacTool jt=com.sun.tools.javac.api.JavacTool.create();
			ArrayList<File> artesterClasspaths=new ArrayList<>();for(File cpf: App.classpathsDirectory.listFiles()){artesterClasspaths.add(cpf);}
			projectClasspaths.addAll(jarFiles);
			App.l("Files to analyze :{     platform classpaths list "+artesterClasspaths.toString()+"     jarFiles     "+jarFiles.toString()+"     javaFiles     "+javaFiles.toString()+" }");
			com.sun.tools.javac.file.JavacFileManager jfm=jt.getStandardFileManager(dc, null, null); jfm.setSymbolFileEnabled(false);jfm.setLocation(StandardLocation.CLASS_OUTPUT, Collections.singletonList(buildDir)); jfm.setLocation(StandardLocation.PLATFORM_CLASS_PATH, artesterClasspaths); jfm.setLocation(StandardLocation.CLASS_PATH, projectClasspaths);
			String javaVersion=App.prefs().getString("java version","1.8");
			ArrayList<String> options=new ArrayList<>();options.add("-source");options.add(javaVersion);options.add("-target");options.add(javaVersion);options.add("-Xlint:all");options.add("-Xdiags:verbose");
			JavacTask jta=(JavacTask)jt.getTask(null, jfm, dc, options, null, javaFiles);
			ArrayList<String> generatedClassFiles=new ArrayList<>();
			jta.addTaskListener(new TaskListener(){@Override public void finished(TaskEvent te){
				if(te.getKind()==TaskEvent.Kind.GENERATE)generatedClassFiles.add(buildDir.getPath()+File.separator+te.getTypeElement().toString().replace(">","").replace("<anonymous ","").replace(".",File.separator).replace("$",File.separator)+".class");
			}});
			if(!hasPendingCompilation.get()||jta.call()){
				jfm.close();
				if(hasPendingCompilation.get()){
					App.l("Generated files by Javac: "+generatedClassFiles.toString());
					activityRef.get().runOnUiThread(()->android.widget.Toast.makeText(App.ref, "completed Javac", android.widget.Toast.LENGTH_SHORT).show());
					willWriteBoosterFile.set(true);
				} hasPendingCompilation.set(false);
				final ArrayList<String> d8args=new ArrayList<>();
				d8args.add(buildDir.getPath());d8args.add("--file-per-class");
				DirectoryTraverser.forEachFile(buildDir, (classFile, loop)->{
					String classFilePath=classFile.getPath(); if(!classFilePath.endsWith(".class"))return;
					if(classFile.getName().contains("$")&&generatedClassFiles.contains(classFilePath.substring(0,classFilePath.indexOf("$"))+".class")&&!generatedClassFiles.contains(classFilePath.replace("$",File.separator))){
						App.l("delete residual class and dex file "+classFilePath);
						classFile.delete();new File(classFilePath.replace(".class",".dex")).delete();
					}else if(!classFile.getName().contains("$")&&!classFiles.contains(classFilePath)){
						App.l("delete residual files associated with "+classFilePath);
						classFile.delete();new File(classFilePath.replace(".class",".dex")).delete();
						willWriteBoosterFile.set(boosterMap.remove(classFilePath.substring(buildDir.getPath().length()+1).replace(".class",".java"))!=null);
						AtomicReference<File> garbage=new AtomicReference<>(classFile.getParentFile());
						DirectoryTraverser.forEachFile(garbage.get(), (gf, loop2)->{if(gf.getName().startsWith(classFile.getName().substring(0,classFile.getName().indexOf("."))))gf.delete();});
						while(garbage.get()!=null){// this if() block is intended to delete directories that are left empty after deleting some residual files.
							DirectoryTraverser.forEachFile(garbage.get(), (gf, loop2)->{if(gf.getName().endsWith(".class")){garbage.set(null);loop2.terminate();}});
							if(garbage.get()==null ||garbage.get().getPath().equals(buildDir.getPath()))break;
							App.l("delete residual dir "+garbage.get().toString());
							garbage.get().delete();garbage.set(garbage.get().getParentFile());
						}
					}else{
						String dex=classFilePath.replace(".class",".dex");dexPaths+=dex+File.pathSeparator;
						if(nonModifiedFiles.contains(classFilePath.contains("$")?classFilePath.substring(0,classFilePath.indexOf("$"))+".class":classFilePath) &&new File(dex).canRead())return;
						hasPendingCompilation.set(d8args.add(classFilePath));
					}
				}); if(hasPendingCompilation.get())App.l("running d8: "+runD8(d8args).toString());
				for(File jf: jarFiles){
					File ojd=new File(buildDir, String.valueOf(jf.length()));ojd.mkdir();
					d8args.clear();synchronized(d8args){}d8args.add(ojd.getPath());
					String jfp=jf.getPath(); ojd=new File(ojd,"classes.dex"); dexPaths+=ojd.getPath()+File.pathSeparator;
					if(nonModifiedFiles.contains(jfp)&&ojd.canRead())continue;
					d8args.add(jfp); App.l("running d8: "+runD8(d8args).toString());
				}
				if(willWriteBoosterFile.get())boosterMap.store(new FileOutputStream(boosterFile), boosterFileComment);
				String[] paths=dexPaths.substring(0,dexPaths.length()-1).split(File.pathSeparator);
				for(String dex: paths){
					for(File esl: new File(dex).getParentFile().listFiles()){
						if(esl.getName().contains("$$ExternalSyntheticLambda"))dexPaths+=esl.getPath()+File.pathSeparator;
					}
				} dexPaths=dexPaths.substring(0,dexPaths.length()-1);
				App.l("dexPaths: "+dexPaths);
				allWentWell=true;
			}else{/* javac compilation error.*/jfm.close();mainTestClass=null;}

			for(Diagnostic d: (List<Diagnostic<? extends JavaFileObject>>)dc.getDiagnostics()){
				int kind=0;String indent=null;
				if(d.getKind()==Diagnostic.Kind.ERROR){kind=1;indent="_______ ";}
				else if(d.getKind()==Diagnostic.Kind.WARNING||d.getKind()==Diagnostic.Kind.MANDATORY_WARNING){kind=2;indent="_________ ";}
				else if(d.getKind()==Diagnostic.Kind.NOTE){kind=3;indent="______ ";}
				if(kind==0)continue;
				String s=null;if(d.getSource()!=null){
					JavaFileObject jfo=(JavaFileObject)d.getSource();
					s="["+shortPaths.get(jfo.getName());
					if(d.getLineNumber()>0)s+=": line "+d.getLineNumber();s+="] ";
					if(d.getPosition()>0){try{
						CharSequence code=jfo.getCharContent(true);code=code.subSequence((int)d.getPosition(), code.length());
						code=code.toString(); s+="starting from: "+(String)code.subSequence(0, Math.min(((String)code).contains("\n")?((String)code).indexOf("\n"):code.length(), 64));
					}catch(IOException ioe){}}
				s+="\n"+indent;}
				s=(s==null?"":s)+d.getMessage(Locale.getDefault()).replace("\n","");
				if(kind==1)msgs.add("ERROR: "+s);
				else if(kind==2)msgs.add("WARNING: "+s);
				else if(kind==3)msgs.add("NOTE: "+s);
			}
		}catch(Exception ex){ex.printStackTrace();}
	return msgs;}

	private ArrayList<String> runD8(ArrayList<String> d8args){
		ArrayList<String> d8argsbase=new ArrayList<>();
		d8argsbase.add("--release");d8argsbase.add("--intermediate");d8argsbase.add("--min-api");d8argsbase.add(String.valueOf(android.os.Build.VERSION.SDK_INT));d8argsbase.add("--output");
		d8argsbase.addAll(d8args);
		com.android.tools.r8.D8.main(d8argsbase.toArray(new String[d8argsbase.size()]));
		return d8argsbase;
	}

	@Override protected void onPostExecute(ArrayList<String> result){Spinner3D.hide(()->{
		if(result!=null)activityRef.get().startActivityForResult(new Intent(activityRef.get(), TestActivity.class).putExtra("currentProject",App.currentProject).putStringArrayListExtra("diagnostics", result).putExtra("dexPaths",dexPaths).putExtra("class",mainTestClass!=null&&allWentWell?mainTestClass:null).addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP|Intent.FLAG_ACTIVITY_CLEAR_TASK|Intent.FLAG_ACTIVITY_NEW_TASK|Intent.FLAG_ACTIVITY_NEW_DOCUMENT), 1);
		activityRef.clear();activityRef=null;mainTestClass=null;
	});}
}